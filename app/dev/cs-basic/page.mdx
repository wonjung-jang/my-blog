import {
  bit,
  color,
  ascii,
  half_adder,
  full_adder,
  os,
  os2,
  anti_virus,
  hdd,
  platter,
  stack,
  queue,
  binary_tree,
} from "./images";

export const metadata = {
  title: "2025년 12월 29일",
  date: "2025-12-29",
  description: "CS 기초 지식",
  type: "dev",
  categories: ["CS", "넓고 얕게 외워서 컴공 전공자되기"],
};

<PostHeader {...metadata} />
<PostContent>
우리가 프로그래밍을 한다는 것은 컴퓨터에게 원하는 결과를 얻을 수 있도록 명령어를 작성하는 행위다.
작성한 프로그램이 어떻게 컴퓨터에 전달돼서 실행되는지에 대해서 얕게 살펴보자.

## 1. 데이터

### 1-1. bit

<CustomImage src={bit} alt={"bit 이미지"} />

컴퓨터의 모든 데이터는 0과 1로 이뤄져있다.
왜냐하면 전기 신호를 사용하기 때문이다.
전기는 흐르거나 안 흐르거나 두 가지 상태만을 갖을 수 있다.
따라서 전기가 흐르면 1, 안 흐르면 0으로 표현한다.
정확히는 전기가 아예 안 흐르는 건 아니고 높은 전압을 1, 낮은 전압을 0으로 표현한다.
이 전기 신호를 수학적으로 표현하고 계산하기 위해 2진수를 사용한다.
2진수의 한 자리는 0 또는 1, 두 가지 상태만 갖을 수 있기 때문에 전기 신호를 표현하기 적합하다.
2진수 숫자(binary digit)를 줄여서 bit라 부른다. bit는 컴퓨터의 최소 표현 단위다.

### 1-2. 4비트와 16진수

컴퓨터의 모든 데이터를 0과1로 표현하고 계산하기에는 다루는 데이터가 크고 복잡하다.
따라서 사람이 좀 더 표현하고 계산하기 쉽도록 16진수를 사용한다.
10진수가 아닌 16진수를 사용하는 이유는 2진수와 진법 전환이 쉽기 때문이다.
16진수의 한 자리는 2^4인 16가지를 표현할 수 있으며 이는 4자리 2진수와 같다.

<CustomImage src={color} alt={"브라우저에서 색상값을 나타내는 이미지"} />

4bit는 16가지 상태를 갖을 수 있고 이는 16진수의 한자리와 같다.
컴퓨터에서 색상 데이터를 다룰 때에도 `#000000 ~ #ffffff` 로 표현한다.
여기서 각 자리는 16진수의 한 자리다. 0은 2진수 0000이고, f는 2진수 1111이다.
16진수 표현은 색상값, 메모리 주소값 등 다양한 곳에서 활용된다.

### 1-3. 용량

8bit는 256가지를 표현할 수 있다.
8bit는 1byte라고도 부른다.
이때부터 용량이라는 개념이 생긴다.
1byte는 컴퓨터 메모리에서 처리하는 최소 정보 단위다.
1024byte는 1KB, 1024KB는 1MB, 1024MB는 1GB, 1024GB는 1TB다.
1024단위로 단위가 변경되는 이유는 1024가 2^10이기 때문이다.

### 1-4. 컴퓨터가 글자와 이미지를 다루는 법

이렇게 컴퓨터에서는 0과 1을 사용해 데이터를 처리한다.
하지만 숫자는 그렇다고 해도 문자나 이미지는 어떻게 표현할 수 있는 걸까??

<CustomImage src={ascii} alt={"ASCII CODE TABLE"} />

먼저 문자는 특정 숫자에 문자를 맵핑하는 방식을 사용한다.
예를 들면 'A'는 65, 'a'는 97에 맵핑되어 있다.
우리가 문자 'A'를 입력하면, 컴퓨터는 문자 'A'에 해당하는 65로 데이터를 처리한다.
컴퓨터 제조사마다 다른 문자를 표현하지 않도록 표준(ASCII)을 만들어 정의했다.
ASCII는 영어까지만 표현할 수 있기 때문에 한국어, 중국어, 일본어 등도 표현할 수 있는 UTF-8 등도 생겨났다.

컴퓨터 모니터는 여러 점으로 이뤄져 있고, 하나의 점을 픽셀이라 부른다.
하나의 픽셀은 색상값 RGB를 갖는다.
Red, Green, Blue 모두 각각 256가지를 표현할 수 있고 8bit, 즉 1byte의 용량을 갖는다.
즉 하나의 픽셀에는 3byte 용량의 색상 정보가 담겨있다.
만약에 투명도 값도 갖고 있다면 4byte로 용량이 늘어난다.
`1024 * 768` 크기의 이미지가 있다면 대략 3MB 크기를 갖는다.
이렇게 모든 픽셀의 정보를 갖고 있는 파일 형식을 bitmap이라 부른다.
하지만 용량이 너무 크기 때문에 보통 jpg, png, webp 등 압축된 파일을 많이 사용한다.

## 2. CPU

컴퓨터의 가장 핵심 장치를 뽑으라면 단연 CPU라 할 수 있다.
CPU는 산술 연산 장치라고 부른다(정확히는 CPU 내부에 ALU).
즉, 더하기, 빼기, 곱하기, 나누기를 하는 장치다.
AND, OR, XOR, NOT 4가지 논리 게이트를 사용하면 산술 연산 장치, 즉 CPU를 만들 수 있다.

### 2-1. 덧셈

산술 연산을 구현할 때 가장 먼저 덧셈을 구현한다.
사실 덧셈만 구현한다면 뺄셈, 곱셈, 나눗셈 모두 구현할 수 있다.

<CustomImage src={half_adder} alt={"반가산기"} />

위 이미지는 input A, B가 각각 AND, XOR 논리 게이트에 이어져 결과 S와 자리 올림 C를 출력하는 반가산기(Half Adder)다.
A와 B에 각각 전압을 흘려 보내면 S에는 전압이 흐르지 않고, C는 전압이 흐른다.
즉 이진수 `1 + 1 = 10`이라는 결과를 출력했다.
하지만 반가산기만으로는 1bit 덧셈만 처리할 수 있다.
왜냐하면 이전 단계에서 자리올림이 발생한 결과를 input으로 받을 수 없기 때문이다.

<CustomImage src={full_adder} alt={"전가산기"} />

따라서 전가산기(Full Adder)를 병렬로 이어붙여 32bit, 64bit 덧셈을 수행한다.
한 자리수에 전가산기 하나씩 담당하여 해당 자리수에 출력할 결과와 자리올림 발생 여부를 다음 단계에게 전달한다.

### 2-2. 뺄셈

뺄셈을 하기 위해서는 보수라는 개념을 알아야 한다.
10진수를 기준으로 6에서 몇을 더해야 10이 될까?
4를 더하면 10이 된다.
이때 6에 대해서 10의 보수는 4라고 표현한다.
즉 보수는 더해서 자리올림이 발생하는 수를 의미한다.

`13 - 6`이라는 연산을 수행한다고 가정해보자.
13에서 6의 보수인 4를 더하면 17이 된다.
그리고 가장 앞자리에서 1을 버리면 7이 된다.
1을 버렸다는 의미는 4bit 전가산기에 넘어가는 숫자를 무시한다는 의미다.

2진수로 표현하면 `1101 - 0110`이다.
0110의 2에 대한 보수는 NOT 게이트를 사용한 결과에 1을 더한 값, 1010이 된다.
`1101 + 1010`은 `0001 0111`이 된다.
4bit 연산이기 때문에 4bit를 넘어간 결과를 무시한다.
이 과정을 Truncation이라 부른다.
즉 Truncation햐면 0111, 7이 된다.

### 2-3. 곰셈과 나눗셈

더하기를 여러 번 수행하면 곱셈, 뺄셈을 여러 번 수행하면 나눗셈이 된다.
하지만 이를 조금 더 효율적으로 처리할 수 있다.

먼저 Shift와 Padding을 알아야 한다.
Shift는 자리수를 밀어내는 행위다.
2진수 0100을 왼쪽으로 Shift하면 1000, 오른쪽으로 Shift하면 0010이 된다.
추가로 Padding은 채워넣는 개념으로 빈 공간에 1을 Padding하거나, 0을 Padding한다.

곱셈은 왼쪽으로 Shift한 뒤, 0을 Padding하면 된다.
0100을 왼쪽으로 Shift하여 100[]로 만들고 빈 공간에 0을 Padding하면 1000, 즉 8이 된다.
곱하기 3을 하고 싶다면 0100을 한 번 더하면 된다.
만약 곱하기 4를 하고 싶다면 같은 과정을 두 번 반복하면 된다.

나눗셈은 반대로 오른쪽으로 Shift한 뒤, 0을 Padding한다.
0100을 []010 0으로 Shift하고 0010 0으로 0을 Padding한다.
여기서 전가산기의 범위가 넘어간 수를 Truncation하면 0010, 즉 2가 된다.
Truncation 처리가 이뤄지기 때문에 정수 나누기 정수의 결과로 소수점이 나오지 않는다.

### 2-4. CPU가 연산하는 과정

이로써 ALU(산술 장치)가 수행되는 원리를 알아봤다.
이제 CPU가 연산하는 과정을 좀 더 자세히 살펴보자.
CPU는 ALU 뿐만 아니라, Register, L1, L2, L3 Cache Memory로 이뤄져 있다.

CPU가 연산하기 위해서는 먼저 RAM에 있는 데이터를 L3, L2, L1 Cache Memory로 올린다.
RAM의 처리 속도보다 CPU의 처리 속도가 월등히 빠르기 때문에 다음 연산에 필요한 데이터를 미리 Cache Memory에 올리는 과정이 필요하다.
이제 ALU가 당장 연산에 필요한 데이터를 Register로 옮긴다.
ALU가 연산을 수행한 결과를 다시 Register, L1, L2, L3 Cache Memory를 거쳐 RAM에 저장된다.
참고로 RAM의 저장 공간은 일련 번호, 주소값이 붙는다.

## 3. 기억 공간

CPU의 기억 공간은 Register, L1, L2, L3 Cache Memory라 부른다.
RAM은 각각의 주소값을 갖고 있다.
두 공간은 휘발성 데이터로 컴퓨터 전원을 끄면 데이터가 사라진다.

우리가 컴퓨터에 프로그램을 설치한다면 HDD(또는 SSD)에 저장된다.
HDD는 비휘발성 데이터로 컴퓨터 전원을 꺼도 데이터가 남아있다.

프로그램을 실행하면 HDD에서 RAM으로 데이터가 복사되어 저장된다.
그리고 RAM에서 CPU로 데이터를 보내 연산을 수행하여 원하는 결과를 얻게 된다.
처리 속도가 CPU, RAM, HDD 순으로 빠르고, 속도 차이가 크다.
이런 속도 차이를 극복하기 위해 저장 공간을 나눠서 관리하게 된다.

### 3-1. HDD와 SSD

<ImageSlider
  images={[
    { src: hdd, alt: "HDD 내부 사진" },
    { src: platter, alt: "Platter" },
  ]}
/>

HDD 내부를 살펴보면 플래터(Platter)가 있다.
플래터는 트랙(Track)으로 나눠지고 트랙은 섹터(Sector)로 나눠진다.
하나의 섹터에는 보통 4KB의 데이터를 저장할 수 있다.
두 개 이상의 섹터를 합쳐서 클러스터(Cluster)라고 부른다.
HDD는 클러스터 단위로 데이터를 관리한다.

두 개의 섹터를 묶어서 하나의 클러스터로 관리한다고 가정해보자.
8KB보다 작은 데이터를 저장할 때는 하나의 클러스터(A)에 저장한다.
다음 데이터를 저장할 때 A의 남은 공간을 활용하지 않고 다음 클러스터에 저장한다.
이는 클러스터의 남은 공간을 계산하는 과정을 거치지 않고 효율적으로 데이터를 관리하기 위해서다.

만약 8KB보다 큰 데이터를 저장한다면 어떻게 될까?
3번 트랙에 1번 클러스터 부터 데이터를 저장한다고 가정해보자.
1, 2, 3 순서대로 데이터를 저장하다가 4번 클러스터에 저장하려고 보니 이미 저장된 데이터가 있다.
그러면 빈 트랙의 클러스터를 찾아 건너뛴 뒤, 마저 데이터를 저장한다.
이렇게 되면 해당 데이터를 읽을 때 디스크가 물리적으로 한 번 더 돌아야 하는 비효율이 발생한다.

예전에는 컴퓨터에서 주기적으로 "컴퓨터 조각모음"을 해줘야 했다.
컴퓨터 조각모음은 클러스터에 저장된 데이터의 자리를 옮겨 분산된 데이터를 이어서 읽을 수 있도록 해주는 작업이다.
최근에는 자동으로 처리해주거나, SSD를 사용하며 필요없어진 작업이 되었다.

0번 섹터의 0번 클러스터는 Master Boot Record라 부른다.
Master Boot Record에는 운영체제의 Boot Loader라는 코드가 저장된다.
컴퓨터의 전원을 키면 Master Boot Record에 있는 Boot Loader가 실행된다.
이를 Booting한다고 표현한다.
예전에는 Master Boot Record를 여러 번 Overwrite하여 못 쓰게 만드는 악성 프로그램이 있었다.
하지만 최근에는 Master Boot Record에 Overwrite를 못하게 하는 등의 안전 장치가 되어 있다.

### 3-2. 파일 시스템

HDD에 어떤 정보가 저장되어 있는지를 File Allocation Table(FAT)이라는 테이블에 저장한다.
컴퓨터에서 프로그램을 삭제한다면 실제로 HDD의 데이터를 초기화하지 않고, FAT에 삭제됐다는 메타 데이터만 저장한다.
따라서 하드 디스크는 삭제한 파일을 복원할 수 있다.

포맷도 빠른 포맷과 느린 포맷이 나눠져있다.
빠른 포맷은 FAT를 초기화하고 느린 포맷은 HDD의 모든 클러스터를 0으로 Overwrite하여 데이터를 완전히 삭제시킨다.

## 4. 운영체제

운영체제는 컴퓨터 내에서 데이터를 빠르고 효율적으로 처리하기 위해 존재한다.
앞서 배운 CPU, RAM, HDD(SSD)를 직접 제어함으로써 언제 데이터를 읽고 쓸지 결정한다.

### 4-1. 기본 용어

운영체제에 대해 알아보기 앞서 기본 용어에 대해서 알아둘 필요가 있다.

1. 동시성
   동시성은 여러 작업을 작게 나눈 뒤 빠르게 번걸아 가면서 수행함으로써 여러 작업이 동시에 수행되는 것처럼 처리하는 방식이다.
2. 병렬성
   병렬성은 여러 작업을 실제로 동시에 수행한다.
   만약 멀티 코어 환경이라면 동시성과 병렬성이 모두 가능하지만, 싱글 코어 환경이라면 병렬성은 불가하다.
3. 원자성
   특정 작업을 수행할 때 다른 작업이 개입되지 못하도록 운영체제에서 Lock을 건다.
   작업이 완료되면 UnLock하여 내보낸 뒤 다음 작업을 이어 받아서 동일한 과정을 반복한다.
   Lock부터 UnLock까지 실행되고 있는 작업에 대해서 원자성을 갖는다고 표현한다.
4. 동기화
   보통 프로그래밍에서 원본이 변경되면 사본 또한 같이 변경되는 현상을 동기화라고 표현한다.
   하지만 운영체제에서는 여러 프로세스나 스레드가 공유 데이터에 접근할 때 데이터의 일관성을 유지하기 위해 순서를 맞추는 행위다.
   특정 작업이 원자성을 갖도록 Lock, UnLock을 하는 행위 등을 수행한다.
5. 교착상태
   A작업이 수행되는 과정에서 필요한 자원을 대기 중인 B작업에서 갖고 있을 때 발생하는 현상이다.
   Lock이 걸렸기 때문에, B작업은 계속 들어오지 못하는 상황에서 수행되는 A작업에는 자원을 전달받지 못하는 상황이라 이러지도 저러지도 못하는 상태다.

### 4-2. 프로그램, 프로세스, 스레드

<CustomImage src={os} alt={"H/W, System S/W, Application S/W 3 Layer"} />

컴퓨터는 크게 3개의 Layer(계층)으로 나눠진다.
가장 기반에 Hardware(Physical), 그 위에 Software(Logical또는 Virtual)가 있다.
Software는 다시 2개로 나눠진다.
System Software가 있고, 그 위에 Application Software가 있다.

우리가 프로그램을 설치하면 HDD에 저장된다.
이를 실행하면 RAM에 사본 데이터가 올라가고 CPU에서 연산이 일어난다.
실행된 프로그램을 프로세스라고 부르고, System Software는 해당 프로세스에게 RAM 메모리를 할당해준다.
프로세스는 스레드라는 실행 단위로 나눠지고, 스레드는 프로세스에 할당된 자원을 공유한다.

### 4-3. User mode와 Kernel mode

System Software에 핵심 역할을 하는 Kernel이 존재한다.
Kernel은 입출력 제어, 자원 관리, 접근 통제 등을 수행한다.
System Software를 Kernel mode, Application Software를 User mode라고도 부른다.

<CustomImage src={os2} alt={"H/W, System S/W, Application S/W 3 Layer가 데이터를 주고받는 형식"} />

프로세스는 User mode에 존재한다.
H/W는 Kernel mode의 Driver와 연결되어 입출력을 주고 받는다.
Kernel mode에서는 Driver에 여러 요소가 연결되어 있다.
User mode에 있는 프로세스에서 Kernel mode의 요소에 직접 접근할 수는 없다.
Kernel mode에서 추상화된 인터페이스를 파일 형태로 User mode에 전달하고 이를 통해 프로세스와 입출력을 주고 받는다.
이렇게 인터페이스 파일을 통해 특정 프로세스에게 특정 요소에 접근 권한을 부여하는 역할을 운영체제가 수행한다.
만약 다른 프로세스가 현재 사용되고 있는 Kernel 요소에 접근해야 한다면, 운영체제는 이를 통제한다.

<CustomImage src={anti_virus} alt={"백신 프로그램이 동작하는 형식"} />

여담으로 백신 프로그램은 조금 다르게 동작한다.
Windows 기준으로 HDD에 저장된 데이터를 GUI 형태의 파일 탐색기를 통해 확인할 수 있다.
파일 탐색기 또한 프로세스로, User mode에 존재한다.
파일 탐색기는 Kernel mode에 파일 시스템과 연결되고 파일 시스템과 Driver 사이에 Filter가 존재한다.
Filter에서는 입출력되는 파일의 정보를 받아 User mode에 있는 백신 프로그램에게 데이터를 보낸다.
백신 프로그램은 바이러스 정보를 갖고 있어, 만약 Filter에서 보낸 파일이 바이러스에 해당한다면 입출력 요청을 차단한다.

### 4-4. 가상 메모리

가상 메모리(Virtual Memory)는 S/W로 구현한 메모리다.
프로세스는 운영체제로부터 32bit 체계 기준으로 4GB의 메모리를 할당받는다.
가상 메모리는 Page 단위로 관리되는데, 한 Page의 용량은 4KB정도다.
이때 Page 공간이 실제 RAM 메모리 공간에 연결되어 있는지, HDD에 연결되어 있는지는 직접 따라가봐야 알 수 있다.

A 프로세스를 실행하다가 B 프로세스를 동시에 실행한다고 가정해보자.
B 프로세스에게 RAM 메모리 공간을 할당해줘야 하는데, A 프로세스로 인해 RAM 공간이 부족하다면 어떻게 될까?

운영체제는 RAM 공간에 있는 Page들을 HDD로 넘긴다.
이를 Page-out(또는 Swap-out)이라 한다.
이렇게 물리적으로 RAM 공간이 부족해도 가상 메모리 덕분에 여러 프로세스를 실행할 수 있다.
다만 RAM 공간이 부족하다면 Page-in, Page-out이 빈번하게 발생한다.
Page-in, Page-out 하는 동안 운영체제는 프로세스를 잠시 멈추기도 하고, HDD를 직접 읽고 쓰는 행위가 반복되기 때문에 속도가 느려진다.

가상 메모리를 사용하여 얻는 이점이 또 있다.
만약 A 프로세스가 어떠한 오류로 인해 죽어버렸다면, 운영체제는 A 프로세스에 할당된 메모리 공간을 강제로 회수한다.
따라서 A 프로세스는 User mode에서 제거되고, 기존에 사용되던 RAM, HDD 메모리들은 사용할 수 있는 공간으로 비워진다.

정리하면 가상 메모리를 사용하는 장점은 크게 3가지다.

1. 각 프로세스 공간을 완벽하게 분리하고 통제할 수 있다.
2. 프로세스 오류가 운영체제에 영향을 주지 못하도록 차단할 수 있다.
3. 메모리가 부족해도 여러 프로그램을 동시에 동작하도록 자원을 효율적으로 활용할 수 있다.

## 5. 프로그래밍

### 5-1. 고급어와 저급어

프로그래밍한 코드를 실행한다.
여기서 실행은 곧 연산이다.
연산의 주체는 CPU다.
CPU는 Machine이라고도 한다.
CPU는 명령에 따라 정해진 연산을 수행하는 기계 장치다.

CPU가 인식할 수 있는 명령어가 있는데, 기계어(Machine Language) 또는 저급어라 한다.
고급어는 S/W 수준에서 사람이 이해하기 쉬운 명령어다.
우리가 작성한 코드는 고급어기 때문에 기계가 이해할 수 없어 번역이 필요하다.
이때 번역을 컴파일(Compile), 번역하는 역할을 컴파일러(Compiler)가 수행한다.
반대로 CPU가 이해하는 기계어를 사람이 이해하기 쉽게 심볼로 바꾼 것을 어셈블리 코드라고 한다.

C언어로 User mode Application Program을 개발하면 CPU가 직접 인식할 수 있도록 컴파일이 필요하다.
이렇게 CPU가 직접 번역하는 언어를 Native Language라고 한다.
운영체제는 H/W에 의존하기 때문에 리눅스용으로 개발했다면 다른 운영체제에서는 동작하지 않는다.

### 5-2. Virtual Machine

VM(Virtual Machine)이란 S/W로 개발한 CPU다.
VM가 이해하는 기계어로 번역되는 언어는 Native Language라 부르지 않고 Managed Language라 부른다.
예를 들어 JAVA는 VM이 이해하는 byte code로 번역되어 실행된다.
JAVA를 위한 VM을 JVM이라 부른다.
Managed Language의 장점은 운영체제에 의존하지 않는다.
JavaScript, Python 등 다양한 Managed Language가 존재하고 각각의 VM이 존재한다.

### 5-3. 인터프리터

컴파일은 코드 전체를 읽어 전체를 번역한 기계어 파일을 생성한 뒤에 실행한다.
인터프리터는 고급어를 한 줄씩 읽고 번역하여 실행한다.
사용자 입장에서는 Machine을 이용하지 않고 직접 실행하는 것처럼 느끼게 된다.
성능면에서 컴파일 방식보다 느리지만, 유연성이 높다는 장점이 있다.
최근에 많은 언어들이 컴파일 방식과 인터프리터 방식을 혼합해서 사용하기 때문에 경계가 모호해지고 있다.

### 5-4. API와 SDK

프로그램은 여러 함수를 호출하여 실행하여 연산한다.
직접 함수를 작성하기도 하지만 이미 만들어진 함수를 사용하기도 한다.

API(Application Programming Interface)는 프로그래밍을 하는데, 쉽게 사용할 수 있도록 제공하는 Interface다.
Interface는 추상화된 함수다.
사용자 입장에서는 내부에서 어떻게 동작하는지 알 필요없이 원하는 기능의 함수를 가져다 사용할 수 있다.

SDK(Software Development Kit)는 API 등을 포함한 개발 도구 묶음이다.
IOS 개발 시에 IOS에서 제공하는 IOS SDK에는 함수 묶음을 제공한다.

API는 특정 기능을 사용하기 위해, SDK는 기능을 포함한 환경을 제공받기 위해 사용한다.

## 6. 자료구조

자료구조에서 자료란 컴퓨터 메모리에 저장된 데이터를 의미한다.
즉 정보를 구조화하여 정리한 것이 자료구조다.
자료구조를 이야기할 때 항상 따라오는 단어는 알고리즘이다.
알고리즘은 문제 해별에 관한 공식으로 특정 문제에 대한 해결책을 코드화 해놓은 것이다.
알고리즘의 대부분은 자료구조에 의존적이다.
자료를 정리하는 이유는 원하는 데이터를 빠르고 효율적으로 찾기 위해서다.
자료구조는 크게 선형, 비선형 두 가지로 나뉜다.
성능면에서 비선형 구조가 좋지만, 구조가 복잡해서 논리적으로 이해하기 어려울 수 있다.
DB는 데이터를 구조화해서 저장하고 제공하는 S/W로 빠르고 효율적인 성능이 중요하기 때문에 Tree 구조(비선형 자료구조의 대표적인 자료구조)로 구현되어 있다.

### 6-1. 선형 자료구조

선형 자료구조를 대표하는 스택(Stack)과 큐(Queue)에 대해서 알아보자

<CustomImage src={stack} alt={"Stack"} />

스택은 FILO(First In Last Out) 구조다.
입출력 지점이 하나로 되어있다.
입력을 Push, 출력을 Pop이라 부른다.
처음 입력된 자료를 꺼내기 위해서는 최신순의 자료들을 모두 꺼내야 한다.
주로 뒤집기나 뒤로 가기와 같은 기능을 사용할 때 활용하기 좋다.

<CustomImage src={queue} alt={"Queue"} />

큐는 FIFO(First In First Out) 구조다.
입출력 지점이 각각 하나씩 존재한다.
입력을 Enqueue, 출력을 Dequeue라고 표현한다.
처음 입력된 자료를 가장 처음으로 꺼낸다.
동기화 작업 시에 유용하게 활용할 수 있다.

### 6-2. 비선형 자료구조

<CustomImage src={binary_tree} alt={"Binary Tree"} />

7개의 자료가 있다고 가정했을 때 선형 자료구조에 저장했다면 최악의 경우 7개를 모두 찾아봐야 한다.
2진트리는 자료당 두 개의 위치정보(링크)를 이용해 셋을 하나로 묶는 형태다.
보통 숫자를 저장할 때 가장 위에 있는 숫자를 기준으로 더 작은 숫자를 왼쪽, 큰 수를 오른쪽에 둔다.
특정 숫자를 찾을 때 최악의 경우에도 3번만 찾아보면 되기 때문에 선형 자료 구조에 비해 성능이 좋다.
2진 트리를 넘어 B트리 B+트리 등 여러 고성능 트리 자료구조가 존재한다.
앞으로 어떤 프로그래밍 언어를 학습하더라도 자료구조는 반드시 학습해야 한다.

</PostContent>
